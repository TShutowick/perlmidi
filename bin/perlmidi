#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;

BEGIN {
	use FindBin qw/$Bin/;
	unshift @INC, "$Bin/../lib";
}

use PerlMIDI::Parser;
use PerlMIDI::Device;
use PerlMIDI::Sequencer;
use PerlMIDI::Constants;

# $dir should be a directory containing .yml files with MIDI tracks
# $dev_path should be a path to a MIDI device, or '/dev/stdout' for testing
my $dir;
my $dev_path = '/dev/stdout';
my $input_path;
my $tempo;
my $help;

GetOptions(
	'dir=s'      => \$dir,
	'device=s'   => \$dev_path,
	'tempo=i'    => \$tempo,
	'help|?'     => \$help,
	'input=s'    => \$input_path,
) or pod2usage(2);

if ($tempo && $input_path) {
	pod2usage("-message" => "Cannot specify both --tempo and --input");
}

$tempo ||= 100;  # Default tempo is 100 BPM

pod2usage(1) if $help;

pod2usage("-message" => "Directory not specified", "-exitval" => 2) unless $dir;

my @files = glob( "$dir/*.yml") or die "no files in $dir";
my @tracks = map { PerlMIDI::Parser::load_file(path => $_) } @files;

my $device = PerlMIDI::Device->new(path => $dev_path);
my $input_device;
if ($input_path) {
	$input_device = PerlMIDI::Device->new(
		path => $input_path,
		mode => '<',
	);
}

my $seq = PerlMIDI::Sequencer->new(
	bpm    => $tempo,
	device => $device,
	tracks => \@tracks,
);

my %dispatch = (
	BYTE_START,    sub { },
	BYTE_CONTINUE, sub { },
	BYTE_STOP,     sub { },
	BYTE_RESET,    sub { $seq->reset() },
	BYTE_CLOCK,    sub { $seq->tick() },
	BYTE_CONTROL,  sub { 
		my $channel = shift;
		# get the controller number and value from the next two bytes
		my $bytes = $input_device->read_bytes(2);
		# honestly I'm not sure what, if anything, to do with these
		# but at least we read them
	},
	# forward note messages to the device
	BYTE_NOTE_ON,  sub {
		my $channel = shift;
		my $bytes = $input_device->read_bytes(2);
		my $note_on = BYTE_NOTE_ON | $channel;
		my $note = $bytes->[0];
		my $velocity = $bytes->[1];
		$device->write_bytes([$note_on, $note, $velocity]);
	},
	BYTE_NOTE_OFF,  sub {
		my $channel = shift;
		my $bytes = $input_device->read_bytes(2);
		my $note_off = BYTE_NOTE_OFF | $channel;
		my $note = $bytes->[0];
		my $velocity = $bytes->[1];
		$device->write_bytes([$note_off, $note, $velocity]);
	},
	BYTE_CHANNEL_PRESSURE, sub {
		my $channel = shift;
		my $bytes = $input_device->read_bytes(1);
		my $pressure = $bytes->[0];
		my $channel_pressure = BYTE_CHANNEL_PRESSURE | $channel;
		$device->write_bytes([$channel_pressure, $pressure]);
	},
	BYTE_AFTERTOUCH, sub {
		my $channel = shift;
		my $bytes = $input_device->read_bytes(1);
		my $aftertouch = BYTE_AFTERTOUCH | $channel;
		my $pressure = $bytes->[0];
		$device->write_bytes([$aftertouch, $pressure]);
	},

);



while(1) {
	if ($input_device) {
		my $bytes = $input_device->read_bytes(1)
			or last;
		if (my $action = $dispatch{$bytes->[0]}) {
			$action->();
			next;
		}
		my $message_type = $bytes->[0] & 0xF0;
		if (my $action = $dispatch{$message_type}) {
			my $channel = $bytes->[0] & 0x0F;
			$action->($channel);
			next;
		}
		warn sprintf("Unknown MIDI byte: 0x%02X", $bytes->[0]);
	} else {
		$seq->tick();
	}
}

__END__

=head1 NAME

perlmidi.pl - A simple MIDI sequencer in Perl

=head1 SYNOPSIS

perlmidi.pl --dir /path/to/data --device /dev/midi0 --tempo 120

=head1 OPTIONS

=over 8

=item B<--dir>

Directory containing MIDI sequences in YAML format.

=item B<--device>

Path to the MIDI device to send output to. Defaults to '/dev/stdout'.

=item B<--tempo>

Sets the tempo in beats per minute. Defaults to 100.

=item B<--help>

Prints this help message and exits.

=item B<--input>

Path to a MIDI input device. If specified, the sequencer will read MIDI clock signals from this device instead of ticking automatically.

=back

=cut
